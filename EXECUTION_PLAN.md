# 🎯 Anki卡片生成器 - 项目执行计划

## 📋 项目概述

**目标**: 基于现有V1版本，进行轻量化重构，优化项目结构和代码质量
**原则**: 保持功能完整，简化技术栈，提升可维护性
**周期**: 7-10天

## 🛠️ 最终技术选型（轻量化）

### 前端技术栈

- **框架**: React 18.2 (保持现有)
- **构建工具**: Create React App (保持现有)
- **语言**: TypeScript 4.9 (保持现有)
- **样式**: Tailwind CSS 3.x (保持现有)
- **状态管理**: React Hooks + Context (保持现有)
- **HTTP客户端**: Axios 1.x (保持现有)
- **图标**: Lucide React (保持现有)
- **测试**: Jest + React Testing Library (保持现有)

### 后端技术栈

- **运行时**: Node.js 18 LTS (保持现有)
- **框架**: Express.js 4.x (保持现有)
- **语言**: TypeScript 4.9 (保持现有)
- **数据库**: SQLite3 (保持现有)
- **文件处理**: Multer + Sharp (保持现有)
- **打包**: JSZip (保持现有)
- **测试**: Jest + Supertest (保持现有)

## 📅 详细执行计划

### Phase 1: 项目结构整理 (1-2天)

#### 1.1 清理项目结构

- [X] **删除冗余项目**: 删除 `anki-card-generator-v2` 目录 ✅ 已完成
- [X] **统一根目录**: 以 `anki-card-generator` 作为唯一项目 ✅ 已完成
- [X] **整理文档**: 合并README和配置文件 ✅ 已完成

#### 1.2 优化目录结构

```
anki-card-generator/
├── 📄 README.md                 # 项目总览和使用指南
├── 📄 package.json             # 根项目脚本配置
├── 📄 .env.example            # 环境变量模板
├── 📄 .gitignore
├── 📄 start.sh                # 一键启动脚本
│
├── 📁 backend/                # 后端服务
│   ├── 📄 package.json
│   ├── 📄 tsconfig.json
│   ├── 📄 jest.config.js
│   └── 📁 src/
│       ├── 📄 index.ts
│       ├── 📁 routes/        # API路由
│       ├── 📁 services/      # 业务逻辑
│       ├── 📁 middleware/    # 中间件
│       ├── 📁 types/         # 类型定义
│       └── 📁 tests/         # 测试文件
│
└── 📁 frontend/               # 前端应用
    ├── 📄 package.json
    ├── 📄 tsconfig.json
    ├── 📄 tailwind.config.js
    ├── 📁 public/
    └── 📁 src/
        ├── 📄 App.tsx
        ├── 📄 index.tsx
        ├── 📁 components/    # React组件
        ├── 📁 services/      # API服务
        ├── 📁 types/         # 类型定义
        └── 📁 __tests__/     # 测试文件
```

#### 1.3 更新根package.json

- [ ] **添加启动脚本**: 统一管理前后端启动
- [ ] **添加开发脚本**: 并行启动前后端开发环境
- [ ] **添加构建脚本**: 统一构建流程
- [ ] **添加测试脚本**: 运行所有测试

### Phase 1: 项目结构整理 (1-2天) ✅ 已完成

#### 1.1 清理项目结构

- [X] **删除冗余项目**: 删除 `anki-card-generator-v2` 目录 ✅
- [X] **统一根目录**: 以 `anki-card-generator` 作为唯一项目 ✅
- [X] **整理文档**: 合并README和配置文件 ✅

#### 1.2 优化目录结构 ✅

- [X] **后端服务**: 完整的Express + TypeScript架构
- [X] **前端应用**: React + TypeScript + Tailwind CSS
- [X] **文档体系**: CLAUDE.md + API.md + 前后端沟通指南

#### 1.3 更新根package.json ✅

- [X] **添加启动脚本**: 统一管理前后端启动 ✅
- [X] **添加开发脚本**: 并行启动前后端开发环境 ✅
- [X] **添加构建脚本**: 统一构建流程 ✅
- [X] **添加测试脚本**: 运行所有测试 ✅

### 📊 专业API设计评估结果

#### ✅ 当前API优势

- **架构合理**: RESTful设计，职责分离清晰
- **功能完整**: 卡片生成、批量处理、质量检查、文件导出
- **技术选型**: TypeScript + Express + Axios 成熟稳定
- **错误处理**: 统一响应格式和状态码
- **安全防护**: 合理的限流机制

#### ⚠️ 识别的关键问题

**P0级问题 (阻塞生产使用)**

- ❌ **数据持久化缺失**: 无法保存历史卡片，用户刷新页面丢失数据
- ❌ **状态管理不足**: 无状态API，缺乏数据持久化层

**P1级问题 (影响性能和用户体验)**

- ⚠️ **异步任务处理**: AI生成同步请求可能导致超时
- ⚠️ **分页搜索缺失**: 大量卡片处理效率低
- ⚠️ **缓存机制缺失**: 重复请求相同问题浪费资源

**P2级问题 (企业级需求)**

- ⚠️ **版本控制缺失**: API升级兼容性问题
- ⚠️ **监控日志不足**: 缺乏详细的性能监控

#### 🚀 API改进建议

**短期改进 (立即实现)**

```typescript
// 新增核心CRUD接口
GET    /api/v1/cards              // 获取卡片列表(分页)
GET    /api/v1/cards/:id          // 获取单个卡片
PUT    /api/v1/cards/:id          // 更新卡片
DELETE /api/v1/cards/:id          // 删除卡片
POST   /api/v1/cards              // 创建卡片(保存到数据库)
```

**中期优化 (1个月内)**

```typescript
// 异步任务处理
POST   /api/v1/tasks/generate     // 提交生成任务
GET    /api/v1/tasks/:id          // 查询任务状态
GET    /api/v1/tasks              // 获取任务列表

// 智能缓存机制
const cacheKey = `qa:${hash(question)}`;
const cachedAnswer = await redis.get(cacheKey);
```

### Phase 2: 数据持久化和API优化 (优先级最高)

#### 2.1 后端数据持久化 (P0级) 🔥

**数据库层实现**:

- [ ] **SQLite数据库**: 添加卡片存储层
- [ ] **数据模型**: 完善AnkiCard实体模型
- [ ] **CRUD服务**: 实现完整的卡片管理服务
- [ ] **数据迁移**: 版本化数据库结构

**API扩展**:

- [ ] **卡片管理API**: GET/PUT/DELETE /api/v1/cards
- [ ] **分页搜索**: 支持分页和关键词搜索
- [ ] **标签系统**: 实现标签管理和过滤

#### 2.2 异步任务处理 (P1级)

**任务队列系统**:

- [ ] **任务队列**: 处理长时间AI调用
- [ ] **状态管理**: 任务状态跟踪和更新
- [ ] **WebSocket**: 实时推送任务进度
- [ ] **任务历史**: 任务执行记录和重试机制

#### 2.3 缓存和性能优化 (P1级)

**智能缓存**:

- [ ] **答案缓存**: 常见问题答案缓存
- [ ] **LRU策略**: 自动淘汰过期缓存
- [ ] **缓存击穿**: 防止缓存雪崩
- [ ] **Redis集成**: 分布式缓存支持

#### 2.4 前端状态管理优化

**状态持久化**:

- [ ] **本地存储**: localStorage保存用户数据
- [ ] **同步机制**: 前后端数据同步
- [ ] **离线支持**: 基础的离线功能
- [ ] **数据备份**: 本地数据备份和恢复

#### 2.5 用户体验优化

**性能提升**:

- [ ] **虚拟滚动**: 大量卡片列表优化
- [ ] **懒加载**: 按需加载卡片内容
- [ ] **预加载**: 智能预加载相关数据
- [ ] **错误恢复**: 网络错误自动重试

#### 2.6 代码质量提升

**类型安全**:

- [ ] **API类型**: 完善后端API类型定义
- [ ] **错误类型**: 统一错误处理类型
- [ ] **验证规则**: 加强输入数据验证
- [ ] **测试覆盖**: 提升测试覆盖率

### Phase 3: 企业级功能完善

#### 3.1 版本控制和API治理

**API版本化**:

- [ ] **版本策略**: /api/v1/, /api/v2/ 规范
- [ ] **向后兼容**: 保持v1接口6个月
- [ ] **迁移工具**: API版本迁移工具
- [ ] **文档同步**: 版本化API文档

#### 3.2 监控和运维

**监控体系**:

- [ ] **性能监控**: API响应时间监控
- [ ] **错误追踪**: 结构化错误日志
- [ ] **健康检查**: 服务状态监控
- [ ] **告警机制**: 关键指标告警

#### 3.3 安全增强

**安全加固**:

- [ ] **API认证**: 用户认证和授权
- [ ] **请求签名**: API请求签名验证
- [ ] **输入过滤**: 增强输入验证和过滤
- [ ] **访问控制**: 基于角色的访问控制

### Phase 3: 配置和部署优化 (1-2天)

#### 3.1 环境配置

- [ ] **统一环境变量**: 创建配置管理模块
- [ ] **配置验证**: 启动时验证必要配置
- [ ] **默认配置**: 提供合理的默认值
- [ ] **开发/生产分离**: 不同环境的配置管理

#### 3.2 构建和部署

- [ ] **Docker配置**: 创建轻量级Dockerfile（可选）
- [ ] **启动脚本**: 优化start.sh脚本
- [ ] **健康检查**: 添加应用健康检查
- [ ] **日志配置**: 优化日志输出和轮转

#### 3.3 性能优化

- [ ] **前端构建**: 优化webpack配置
- [ ] **图片处理**: 优化Sharp配置
- [ ] **内存管理**: 监控和优化内存使用
- [ ] **并发控制**: 优化批量处理的并发数

### Phase 4: 测试和文档 (1-2天)

#### 4.1 测试完善

- [ ] **单元测试**: 确保核心逻辑测试覆盖率 > 80%
- [ ] **集成测试**: 添加API端点集成测试
- [ ] **E2E测试**: 添加关键流程端到端测试
- [ ] **性能测试**: 验证批量处理性能

#### 4.2 文档更新

- [ ] **README更新**: 包含安装、配置、使用说明
- [ ] **API文档**: 更新API接口文档
- [ ] **开发指南**: 添加开发者文档
- [ ] **部署指南**: 添加部署说明

## 🎯 具体任务清单

### 必须完成的核心任务

#### 高优先级 (P0)

- [ ] **项目结构清理**: 删除anki-card-generator-v2，整理目录结构
- [ ] **核心功能验证**: 确保所有现有功能正常工作
- [ ] **类型安全**: 修复所有TypeScript类型错误
- [ ] **错误处理**: 添加全局错误处理和用户友好的错误提示
- [ ] **基础测试**: 确保所有API端点有基础测试覆盖

#### 中优先级 (P1)

- [ ] **代码优化**: 简化复杂的组件和服务逻辑
- [ ] **性能优化**: 优化图片处理和批量操作性能
- [ ] **用户体验**: 改进加载状态和交互反馈
- [ ] **配置管理**: 统一环境变量和配置管理
- [ ] **文档完善**: 更新README和API文档

#### 低优先级 (P2)

- [ ] **Docker化**: 创建Docker配置文件
- [ ] **监控日志**: 添加应用监控和日志管理
- [ ] **缓存策略**: 添加响应缓存机制
- [ ] **国际化**: 添加多语言支持（如果需要）

### 技术债务清理

#### 代码质量

- [ ] **删除未使用代码**: 清理import和未使用的函数
- [ ] **统一命名规范**: 确保变量、函数、文件命名一致
- [ ] **代码格式化**: 使用Prettier统一代码格式
- [ ] **ESLint规则**: 修复所有ESLint警告

#### 依赖管理

- [ ] **依赖版本检查**: 确保所有依赖是稳定版本
- [ ] **安全漏洞检查**: 运行npm audit修复安全问题
- [ ] **未使用依赖**: 删除未使用的npm包
- [ ] **包大小优化**: 分析和优化bundle大小

## 📊 当前项目进度与验收标准

### ✅ 已完成功能 (Phase 1)

- [X] **项目结构整理**: 统一目录结构，删除冗余项目 ✅
- [X] **TypeScript编译**: 前端无编译错误，类型安全 ✅
- [X] **服务启动**: 前后端服务正常启动 ✅
- [X] **文档体系**: 完整的开发和使用文档 ✅
- [X] **Git规范**: 原子性提交，版本控制良好 ✅

### 🔄 当前可验证功能

- ✅ **卡片生成**: AI生成卡片功能正常
- ✅ **图片上传**: 图片处理和OCR功能正常
- ✅ **质量检查**: 卡片质量评估系统正常
- ✅ **文件导出**: Anki .apkg文件生成正常
- ✅ **批量操作**: 批量生成卡片功能正常

### ⚠️ 待改进功能 (Phase 2+)

- ❌ **数据持久化**: 无法保存历史卡片，刷新页面丢失数据
- ❌ **卡片管理**: 缺少编辑、删除、搜索功能
- ❌ **状态管理**: 无状态API，数据不持久化
- ❌ **分页支持**: 大量数据时性能问题

### 🎯 Phase 2 优先级目标 (数据持久化)

#### P0级目标 (阻塞生产使用)

- [ ] **SQLite数据库**: 添加卡片持久化存储
- [ ] **CRUD API**: 完整的卡片管理接口
- [ ] **前端状态同步**: localStorage + 后端同步
- [ ] **数据恢复**: 本地数据备份和恢复

#### P1级目标 (性能优化)

- [ ] **异步任务**: 处理长时间AI调用
- [ ] **智能缓存**: 常见问题答案缓存
- [ ] **虚拟滚动**: 大量卡片列表优化
- [ ] **搜索功能**: 卡片关键词搜索

### 📈 性能基准对比

| 功能     | 当前状态        | 目标状态    | 状态 |
| -------- | --------------- | ----------- | ---- |
| 卡片生成 | ✅ 正常 (30秒)  | ✅ 保持     | 完成 |
| 批量生成 | ✅ 正常 (2分钟) | ✅ 保持     | 完成 |
| 数据保存 | ❌ 丢失数据     | ✅ 持久化   | P0   |
| 卡片搜索 | ❌ 不支持       | ✅ 支持     | P1   |
| 缓存命中 | ❌ 无缓存       | ⚠️ 50%+   | P1   |
| 任务超时 | ⚠️ 2分钟超时  | ✅ 异步处理 | P1   |

### 🔍 计划合理性重新评估

#### ✅ 原计划优势

1. **技术选型合理**: 轻量化技术栈，避免过度工程
2. **执行优先级明确**: 从基础到高级，渐进式改进
3. **文档完善**: 为开发和使用提供详细指导

#### 🔄 计划调整建议

**原计划问题**:

- 缺乏数据持久化优先级认知
- 对API架构问题估计不足
- 分阶段目标不够具体

**调整后计划优势**:

- **立即解决P0问题**: 数据持久化作为Phase 2核心
- **API驱动开发**: 基于API评估结果优化架构
- **用户价值优先**: 每个阶段都解决实际用户问题

#### 🎯 新的执行重点

**Phase 2 (立即开始)**:

1. 数据库层实现 (1周)
2. CRUD API开发 (1周)
3. 前端状态管理 (1周)

**Phase 3 (功能完善)**:

1. 异步任务和缓存 (1周)
2. 性能优化 (1周)

**Phase 4 (企业级)**:

1. 版本控制和监控 (按需)

### 📋 关键成功指标 (KPI)

#### Phase 2 成功标准

- [X] **数据不丢失**: 用户刷新页面数据保持
- [X] **完整管理**: 卡片增删改查功能
- [X] **基础搜索**: 关键词搜索和过滤
- [X] **性能提升**: 大量数据不卡顿

#### 最终验收标准

- ✅ **功能完整**: 所有卡片操作功能正常
- ✅ **数据安全**: 数据持久化和备份机制
- ✅ **性能优秀**: 支持大规模数据处理
- ✅ **用户友好**: 直观的界面和操作流程
- ✅ **代码质量**: 高测试覆盖率，低bug率

## 🚨 风险控制

### 技术风险

- **风险**: 重构可能破坏现有功能
- **缓解**: 逐步重构，每步都进行功能验证

### 进度风险

- **风险**: 重构时间超出预期
- **缓解**: 优先完成核心功能，非关键功能可后续优化

### 质量风险

- **风险**: 新代码引入bug
- **缓解**: 充分测试，代码审查

## 📝 执行注意事项

1. **保持功能完整性**: 不删除任何现有功能
2. **渐进式重构**: 每次只改一小部分，立即测试
3. **向后兼容**: API接口保持兼容
4. **用户体验**: 确保用户界面体验不下降
5. **文档同步**: 代码变更同步更新文档

---

## 🎉 成功标准

重构完成后，项目将具备：

- **更清晰的项目结构**: 易于理解和维护
- **更稳定的代码质量**: 减少bug和技术债务
- **更好的用户体验**: 更快的响应和更好的错误处理
- **更完善的文档**: 便于后续开发和维护
- **更轻松的部署**: 简化的配置和部署流程
